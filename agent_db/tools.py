# -*- coding: utf-8 -*-
import os
import sys

# Configurar codifica√ß√£o UTF-8 explicitamente
if sys.platform.startswith('win'):
    os.environ['PYTHONIOENCODING'] = 'utf-8'

from langchain_community.utilities import SQLDatabase
from langchain_community.agent_toolkits import create_sql_agent
from langchain.chat_models import init_chat_model
from langchain.tools import tool
import time
import re
from .rate_limiter import RateLimiter, SmartCache

class AgentTools:
    def __init__(self, db_uri: str):
        # Inicializar rate limiter e cache inteligente
        self.rate_limiter = RateLimiter(max_requests_per_second=1, max_requests_per_minute=20)
        self.smart_cache = SmartCache(default_ttl=600)  # 10 minutos
        self.error_patterns = {
            'column_not_exist': r'column "([^"]+)" does not exist',
            'table_not_exist': r'relation "([^"]+)" does not exist',
            'date_range_error': r'year (-?\d+) is out of range',
            'syntax_error': r'syntax error at or near "([^"]+)"'
        }
        
        try:
            print(f"üîó Tentando conectar ao banco: {db_uri.replace(db_uri.split('@')[0].split('//')[1], '***')}")
            
            # Configurar banco com seguran√ßa e amostras 
            self.db = SQLDatabase.from_uri(
                db_uri,
                sample_rows_in_table_info=3,  # Mostrar 3 linhas de exemplo
                schema='public',
                # Removendo include_tables para permitir acesso a todas as tabelas dispon√≠veis
                custom_table_info=None,
                view_support=False,
                max_string_length=300
            )
            print("‚úÖ Conex√£o com banco estabelecida")
            
            # Inicializar o modelo LLM
            self.llm = init_chat_model("gemini-2.5-flash", model_provider="google_genai")
            
            # Prompt de sistema melhorado com conhecimento espec√≠fico
            system_prompt = f"""Voc√™ √© um especialista em SQL e an√°lise de dados com conhecimento espec√≠fico do banco de dados PostgreSQL da empresa.

                            üö® ATEN√á√ÉO CR√çTICA: A tabela 'entidades' N√ÉO possui coluna 'id'. NUNCA use 'id' em consultas!

                            CONHECIMENTO OBRIGAT√ìRIO DO BANCO - USE EXATAMENTE ESTES NOMES:

                            üîπ TABELA: entidades (Clientes/Fornecedores/Vendedores/Transportadoras)
                            CAMPOS OBRIGAT√ìRIOS (MEMORIZE ESTES NOMES):
                            - enti_clie (ID da entidade - USE ESTE CAMPO como identificador √∫nico, NUNCA "id")
                            - enti_nome (Nome da entidade - USE ESTE CAMPO, NUNCA "nome")
                            - enti_tipo_enti (Tipo da entidade - USE ESTE CAMPO, NUNCA "tipo")
                            - enti_ende (Endere√ßo)
                            - enti_esta (Estado)
                            - enti_tele (Telefone)
                            - enti_celu (Celular)

                            ‚ö†Ô∏è CAMPOS QUE N√ÉO EXISTEM (NUNCA USE):
                            - id (N√ÉO EXISTE - use enti_clie)
                            - nome (N√ÉO EXISTE - use enti_nome)
                            - tipo (N√ÉO EXISTE - use enti_tipo_enti)
                            - codigo (N√ÉO EXISTE - use enti_clie)
                            - nunca use a tabela de faturamento, sempre a de pedidos, ou notas fiscais.

                            VALORES DO CAMPO enti_tipo_enti:
                            - 'CL' = Cliente
                            - 'FO' = Fornecedor  
                            - 'VE' = Vendedor
                            - 'TR' = Transportadora
                            - 'OU' = Outros
                            - 'AM' = Ambos

                            üîπ TABELA: produtos
                            CAMPOS: prod_codi, prod_nome

                            üîπ TABELA: saldosprodutos  
                            CAMPOS: sapr_prod, sapr_sald

                            üîπ TABELA: pedidosvenda
                            CAMPOS: pedi_nume, pedi_data, pedi_forn, pedi_tota

                            üîπ TABELA: itenspedidovenda
                            CAMPOS: iped_pedi, iped_prod, iped_quan, iped_unit, iped_tota

                            üîπ TABELA: titulospagar
                            CAMPOS: titu_id, titu_forn, titu_valo, titu_venc

                            üîπ TABELA: titulosreceber
                            CAMPOS: titu_id, titu_clie, titu_valo, titu_venc

                            RELACIONAMENTOS IMPORTANTES:
                            - saldosprodutos.sapr_prod ‚Üí produtos.prod_codi
                            - itenspedidovenda.iped_prod ‚Üí produtos.prod_codi
                            - pedidosvenda.pedi_forn ‚Üí entidades.enti_clie
                            - itenspedidovenda.iped_pedi ‚Üí pedidosvenda.pedi_nume
                            - titulosreceber.titu_clie ‚Üí entidades.enti_clie

                            REGRAS CR√çTICAS:
                            1. üö® NUNCA use 'id', 'nome', 'tipo' - use enti_clie, enti_nome, enti_tipo_enti
                            2. SEMPRE use os nomes EXATOS dos campos listados acima
                            3. NUNCA invente nomes de colunas
                            4. Para contagem: COUNT(enti_clie) ou COUNT(*) - NUNCA COUNT(id)
                            4a. Para soma de itens mais vendidos : SUM(iped_quan) - NUNCA SUM(id)
                            4b. Para soma de valor total de vendas : SUM(iped_tota) - NUNCA SUM(iped_quan)
                            4c. Para soma de valor total de titulos a pagar : SUM(titu_valo) - NUNCA SUM(titu_id)
                            4d. Para soma de valor total de titulos a receber : SUM(titu_valo) - NUNCA SUM(titu_id)
                            4e. Para buscar o valor do estoque a tabela correta √© tabelaprecos, use o campo tabe_prod e tabe_prco
                            4f. Para buscar o valor do estoque de um produto espec√≠fico use o campo sapr_prod e sapr_sald
                            5. SEMPRE use o campo enti_clie para filtros e joins
                            6. SEMPRE use LIMIT para evitar sobrecarga
                            7. APENAS comandos SELECT s√£o permitidos
                            8. Se erro de coluna, consulte esta lista de campos obrigat√≥rios
                            9. Responda em portugu√™s brasileiro com markdown
                            10. Inclua insights e an√°lises dos dados
                            11. Termine com sugest√µes de pr√≥ximas consultas mas n√£o as sqls, apenas as perguntas.

                            EXEMPLOS CORRETOS OBRIGAT√ìRIOS:

                            Para contar entidades:
                            SELECT COUNT(*) as total FROM entidades;

                            Para listar entidades:
                            SELECT enti_clie as codigo, enti_nome as nome, enti_tipo_enti as tipo 
                            FROM entidades LIMIT 10;

                            Para entidades por tipo:
                            SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade 
                            FROM entidades 
                            GROUP BY enti_tipo_enti 
                            ORDER BY quantidade DESC;
                            """
                                        
            # Criar o agente SQL com configura√ß√µes de seguran√ßa
            self.sql_agent = create_sql_agent(
                llm=self.llm,
                db=self.db,
                agent_type="openai-tools",
                verbose=True,
                system_message=system_prompt,
              
            )
            print('‚úÖ Database inicializado:', self.db.dialect)
            print('‚úÖ SQL Agent criado com sucesso (modo read-only)')
            print('‚úÖ Tabelas configuradas:', ['produtos', 'saldosprodutos', 'entidades', 'titulospagar', 'titulosreceber'])
        except UnicodeDecodeError as ude:
            print(f'‚ùå Erro de codifica√ß√£o UTF-8 ao inicializar AgentTools: {ude}')
            print('üí° Sugest√£o: Verifique se todos os arquivos est√£o salvos em UTF-8')
            raise
        except ImportError as ie:
            print(f'‚ùå Erro de importa√ß√£o: {ie}')
            print('üí° Sugest√£o: Verifique se todas as depend√™ncias est√£o instaladas')
            raise
        except ConnectionError as ce:
            print(f'‚ùå Erro de conex√£o com banco: {ce}')
            print('üí° Sugest√£o: Verifique se o PostgreSQL est√° rodando e as credenciais est√£o corretas')
            raise
        except Exception as e:
            print(f'‚ùå Erro ao inicializar AgentTools: {e}')
            print(f'‚ùå Tipo do erro: {type(e).__name__}')
            print(f'‚ùå Detalhes: {str(e)}')
            raise

    def query_database(self, question: str) -> str:
        """Executa uma consulta SQL no banco de dados com rate limiting e cache inteligente."""
        
        # Verificar cache primeiro
        cache_key = f"query_{hash(question)}"
        cached_result = self.smart_cache.get(cache_key)
        if cached_result:
            return f"üìã **[Cache]** {cached_result}"
        
        # Verificar rate limiting
        if not self.rate_limiter.can_proceed():
            wait_time = self.rate_limiter.wait_time()
            return f"‚è≥ **Rate limit atingido.** Aguarde {wait_time:.1f} segundos antes de fazer nova consulta.\n\nüí° **Dica:** Use consultas mais espec√≠ficas para otimizar o cache."
        
        try:
            # Pr√©-processar pergunta para evitar erros comuns
            processed_question = self._preprocess_question(question)
            
            # Adicionar contexto para respostas em linguagem natural
            enhanced_question = f"""
            {processed_question}
            
            INSTRU√á√ïES CR√çTICAS:
            - SEMPRE use LIMIT nas consultas para evitar sobrecarga
            4. Para contagem: COUNT(enti_clie) ou COUNT(*) - NUNCA COUNT(id)
            4a. Para soma de itens mais vendidos : SUM(iped_quan) - NUNCA SUM(id)
            4b. Para soma de valor total de vendas : SUM(iped_tota) - NUNCA SUM(iped_quan)
            4c. Para soma de valor total de titulos a pagar : SUM(titu_valo) - NUNCA SUM(titu_id)
            4d. Para soma de valor total de titulos a receber : SUM(titu_valo) - NUNCA SUM(titu_id)
            4e. Para buscar o valor do estoque a tabela correta √© tabelaprecos, use o campo tabe_prod e tabe_prco
            4f. Para buscar o valor do estoque de um produto espec√≠fico use o campo sapr_prod e sapr_sald
            - o sistmea tem os prefixos de _empr e fili, sempre que solicitado empresa e filial filtrar, pela empresa e filial
            - Se encontrar erro de coluna inexistente, tente consultar o schema primeiro
            - Para datas, use fun√ß√µes de convers√£o adequadas (TO_DATE, CAST)
            - Responda em linguagem natural com insights sobre os dados
            - Use formata√ß√£o markdown para melhor apresenta√ß√£o
            - Se n√£o encontrar dados, explique poss√≠veis motivos
            - Inclua an√°lises e interpreta√ß√µes dos resultados
            - Termine com sugest√µes de consultas relacionadas
            
            TRATAMENTO DE ERROS:
            - Se coluna n√£o existir, sugira colunas similares
            - Se tabela n√£o existir, liste tabelas dispon√≠veis
            - Para erros de data, use formatos padr√£o (YYYY-MM-DD)
            """
            
            result = self.sql_agent.invoke({"input": enhanced_question})
            output = result.get("output", str(result))
            
            # Verificar se houve erro e tentar recupera√ß√£o
            if self._has_critical_error(output):
                recovery_result = self._attempt_error_recovery(question, output)
                if recovery_result:
                    output = recovery_result
            
            # Salvar no cache apenas se n√£o houve erro
            if not self._has_critical_error(output):
                self.smart_cache.set(cache_key, output)
            
            return output
            
        except Exception as e:
            error_msg = str(e)
            error_type = self._classify_error(error_msg)
            
            return f"""**üö® Erro na consulta:** {error_type}

**Detalhes:** {error_msg}

**üîß Solu√ß√µes sugeridas:**
{self._get_error_solutions(error_type, error_msg)}

**üí° Dicas para evitar erros:**
- Use consultas mais simples e espec√≠ficas
- Consulte o schema das tabelas primeiro
- Evite consultas muito complexas
- Use LIMIT para limitar resultados
"""
    
    def get_table_info(self, table_name: str) -> str:
        """Retorna as informa√ß√µes de uma tabela espec√≠fica com tratamento robusto de erros de data."""
        try:
            return self.db.get_table_info([table_name])
        except Exception as e:
            error_msg = str(e)
            # Tratamento espec√≠fico para erros de data fora do range
            if 'year' in error_msg and 'is out of range' in error_msg:
                print(f"‚ö†Ô∏è Aviso: Tabela {table_name} cont√©m dados com datas inv√°lidas, mas schema ser√° acessado")
                # Tentar acessar schema sem dados de exemplo
                try:
                    # Usar uma consulta direta para obter apenas a estrutura
                    result = self.db.run(f"SELECT column_name, data_type FROM information_schema.columns WHERE table_name = '{table_name}' AND table_schema = 'public' LIMIT 20")
                    if result:
                        return f"Tabela {table_name} (estrutura b√°sica - dados com datas inv√°lidas ignorados):\n{result}"
                    else:
                        return f"Tabela {table_name}: Estrutura dispon√≠vel (dados com datas inv√°lidas ignorados)"
                except:
                    return f"Tabela {table_name}: Dispon√≠vel (dados com datas inv√°lidas ignorados - use consultas diretas)"
            return f"Erro ao obter informa√ß√µes da tabela {table_name}: {str(e)}"
    
    def get_database_schema(self, table_names: str = None) -> str:
        """Retorna informa√ß√µes sobre todas as tabelas configuradas com tratamento robusto de erros."""
        try:
            if table_names:
                tables = [t.strip() for t in table_names.split(',')]
            else:
                tables = ['produtos', 'saldosprodutos', 'entidades', 'titulospagar', 'titulosreceber']
            
            schema_info = "## Estrutura do Banco de Dados\n\n"
            
            for table in tables:
                try:
                    info = self.get_table_info(table)  # Usar nossa fun√ß√£o melhorada
                    schema_info += f"### Tabela: {table}\n```sql\n{info}\n```\n\n"
                except Exception as e:
                    error_msg = str(e)
                    if 'year' in error_msg and 'is out of range' in error_msg:
                        fallback_schema = self._get_fallback_schema(table)
                        schema_info += f"### Tabela: {table}\n{fallback_schema}\n\n"
                    else:
                        schema_info += f"### Tabela: {table}\n*Tabela n√£o encontrada ou sem permiss√£o: {error_msg}*\n\n"
            
            return schema_info
        except Exception as e:
            return f"Erro ao obter schema do banco: {str(e)}"
    
    def _get_fallback_schema(self, table_name: str) -> str:
        """Retorna schema conhecido quando h√° erro de data inv√°lida"""
        schemas = {
            'entidades': """
‚ö†Ô∏è Schema obtido via fallback devido a dados de data inv√°lidos:

```sql
CREATE TABLE entidades (
    enti_clie INTEGER PRIMARY KEY,
    enti_nome VARCHAR(100),
    enti_tipo_enti VARCHAR(2), -- CL=Cliente, FO=Fornecedor, VE=Vendedor, TR=Transportadora
    enti_ende VARCHAR(200),
    enti_esta VARCHAR(2),
    enti_tele VARCHAR(20),
    enti_celu VARCHAR(20),
    enti_cnpj VARCHAR(18),
    enti_cpf VARCHAR(14)
);
```
            """,
            'titulospagar': """
‚ö†Ô∏è Schema obtido via fallback devido a dados de data inv√°lidos:

```sql
CREATE TABLE titulospagar (
    titu_id INTEGER PRIMARY KEY,
    titu_forn INTEGER, -- Refer√™ncia para entidades
    titu_valo DECIMAL(15,2),
    titu_venc DATE,
    titu_desc VARCHAR(200),
    titu_empr INTEGER -- Refer√™ncia para empresas
);
```
            """,
            'empresas': """
‚ö†Ô∏è Schema obtido via fallback devido a dados de data inv√°lidos:

```sql
CREATE TABLE empresas (
    empr_codi INTEGER PRIMARY KEY,
    empr_nome VARCHAR(100),
    empr_fant VARCHAR(100),
    empr_cnpj VARCHAR(18)
);
```
            """,
            'produtos': """
‚ö†Ô∏è Schema obtido via fallback devido a dados de data inv√°lidos:

```sql
CREATE TABLE produtos (
    prod_codi INTEGER PRIMARY KEY,
    prod_nome VARCHAR(200),
    prod_prec DECIMAL(15,2)
);
```
            """,
            'pedidosvenda': """
‚ö†Ô∏è Schema obtido via fallback devido a dados de data inv√°lidos:

```sql
CREATE TABLE pedidosvenda (
    pedi_nume INTEGER PRIMARY KEY,
    pedi_data DATE,
    pedi_forn INTEGER, -- Refer√™ncia para entidades
    pedi_tota DECIMAL(15,2)
);
```
            """
        }
        
        if table_name in schemas:
            return schemas[table_name]
        else:
            return f"*Tabela {table_name} dispon√≠vel (cont√©m dados com datas inv√°lidas - use consultas diretas)*"
    
    def _preprocess_question(self, question: str) -> str:
        """Pr√©-processa a pergunta para evitar erros comuns e mapear termos para nomes corretos"""
        
        # Detectar se √© uma pergunta sobre contagem/quantidade de entidades
        if any(term in question.lower() for term in ['quantos', 'quantidade', 'numero', 'n√∫mero', 'count', 'clientes', 'entidades']):
            return """
            PERGUNTA: Quantos clientes/entidades existem e quais s√£o seus nomes?
            
            ATEN√á√ÉO CR√çTICA: A tabela 'entidades' N√ÉO possui coluna 'id'. 
            
            CAMPOS CORRETOS da tabela entidades:
            - enti_clie (c√≥digo do cliente - use como identificador √∫nico)
            - enti_nome (nome da entidade)
            - enti_tipo_enti (tipo: CL=Cliente, FO=Fornecedor, etc.)
            - enti_ende (endere√ßo)
            - enti_esta (estado)
            - enti_tele (telefone)
            - enti_celu (celular)
            
            CONSULTA CORRETA OBRIGAT√ìRIA:
            SELECT COUNT(*) as total_entidades, 
                   COUNT(CASE WHEN enti_tipo_enti = 'CL' THEN 1 END) as total_clientes
            FROM entidades;
            
            Para listar nomes, use:
            SELECT enti_clie as codigo, enti_nome as nome, enti_tipo_enti as tipo 
            FROM entidades 
            WHERE enti_tipo_enti = 'CL' 
            ORDER BY enti_nome 
            LIMIT 10;
            
            NUNCA use 'id' - sempre use 'enti_clie' como identificador!
            """
        
        # Mapeamento inteligente de termos comuns
        replacements = {
            # Termos para entidades
            'entidades por tipo': 'SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade FROM entidades GROUP BY enti_tipo_enti ORDER BY quantidade DESC',
            'tipos de entidades': 'SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade FROM entidades GROUP BY enti_tipo_enti ORDER BY quantidade DESC',
            'gr√°fico das entidades': 'SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade FROM entidades GROUP BY enti_tipo_enti ORDER BY quantidade DESC',
            'grafico das entidades': 'SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade FROM entidades GROUP BY enti_tipo_enti ORDER BY quantidade DESC',
            
            # Mapeamento de campos - CR√çTICO: remover refer√™ncias a 'id'
            'id_cliente': 'enti_clie',
            'codigo_cliente': 'enti_clie', 
            'nome_cliente': 'enti_nome',
            'nome_entidade': 'enti_nome',
            'tipo_entidade': 'enti_tipo_enti',
            'tipo_cliente': 'enti_tipo_enti',
            'endereco': 'enti_ende',
            'estado': 'enti_esta',
            'telefone': 'enti_tele',
            'celular': 'enti_celu',
            
            # Produtos
            'codigo_produto': 'prod_codi',
            'nome_produto': 'prod_nome',
            
            # Pedidos
            'numero_pedido': 'pedi_nume',
            'data_pedido': 'pedi_data',
            'cliente_pedido': 'pedi_forn',
            'total_pedido': 'pedi_tota',
            'valor_total': 'pedi_tota',
            
            # Itens pedido
            'quantidade': 'iped_quan',
            'preco_unitario': 'iped_unit',
            'valor_item': 'iped_tota',
            
            # T√≠tulos
            'valor_titulo': 'titu_valo',
            'vencimento': 'titu_venc',
            
            # Termos gen√©ricos que causam erro - CR√çTICO
            ' tipo ': ' enti_tipo_enti ',
            ' id ': ' enti_clie ',
            ' nome ': ' enti_nome ',
            ' codigo ': ' enti_clie ',
            'count(id)': 'COUNT(enti_clie)',
            'COUNT(id)': 'COUNT(enti_clie)',
            'select id': 'SELECT enti_clie',
            'SELECT id': 'SELECT enti_clie'
        }
        
        processed = question.lower()
        
        # Aplicar substitui√ß√µes
        for old_term, new_term in replacements.items():
            processed = processed.replace(old_term.lower(), new_term)
        
        # Adicionar contexto espec√≠fico para consultas de entidades
        if 'tpo de entidade' in processed and ('tipo' in question.lower() or 'gr√°fico' in question.lower() or 'grafico' in question.lower()):
            processed = """
            Crie um gr√°fico/relat√≥rio das entidades agrupadas por tipo.
            
            IMPORTANTE: Use EXATAMENTE esta consulta:
            SELECT enti_tipo_enti as tipo, COUNT(*) as quantidade 
            FROM entidades 
            GROUP BY enti_tipo_enti 
            ORDER BY quantidade DESC
            LIMIT 10;
            
            Depois explique o significado de cada tipo:
            - CL = Cliente
            - FO = Fornecedor  
            - VE = Vendedor
            - TR = Transportadora
            - OU = Outros
            - AM = Ambos
            """
        
        # Tratar consultas de aniversariantes
        if 'aniversario' in question or 'nascimento' or 'aniversar' in question or 'data de nascimento' in question:
            processed = """
            Liste os pr√≥ximos aniversariantes.
            
            IMPORTANTE: Use EXATAMENTE esta consulta para evitar erros de data:
            
            
                WITH dados_validos AS (
                    SELECT 
                        DISTINCT enti_empr, 
                        enti_clie AS codigo,
                        enti_nome AS nome,
                        enti_tipo_enti AS tipo,
                        enti_dana,
                        CASE 
                            WHEN enti_dana IS NOT NULL AND EXTRACT(YEAR FROM enti_dana) BETWEEN 1900 AND 2100 
                            THEN TO_CHAR(enti_dana, 'DD/MM') 
                            ELSE 'Data inv√°lida' 
                        END AS aniversario,
                        CASE 
                            WHEN enti_dana IS NOT NULL AND EXTRACT(YEAR FROM enti_dana) BETWEEN 1900 AND 2100 
                            THEN EXTRACT(MONTH FROM enti_dana)
                            ELSE 99 
                        END AS mes_nascimento,
                        CASE 
                            WHEN enti_dana IS NOT NULL AND EXTRACT(YEAR FROM enti_dana) BETWEEN 1900 AND 2100 
                            THEN EXTRACT(DAY FROM enti_dana)    
                            ELSE 99
                        END AS dia_nascimento,
                        COALESCE(enti_fone, enti_celu, 'Sem telefone') AS contato,
                        enti_emai AS email
                    FROM entidades
                    WHERE enti_dana IS NOT NULL
                    AND EXTRACT(YEAR FROM enti_dana) BETWEEN 1900 AND 2100
                ),
                aniversarios_validos AS (
                    SELECT *,
                        MAKE_DATE(EXTRACT(YEAR FROM CURRENT_DATE)::int, 
                                    mes_nascimento::int, 
                                    dia_nascimento::int) AS aniversario_deste_ano
                    FROM dados_validos
                    WHERE
                    enti_empr = 1 AND
                    mes_nascimento BETWEEN 1 AND 12
                    AND dia_nascimento BETWEEN 1 AND 31
                    -- Filtra combina√ß√µes imposs√≠veis
                    AND (mes_nascimento, dia_nascimento) NOT IN ((2,30), (2,31), (4,31), (6,31), (9,31), (11,31))
                    -- Exclui 29/02 em ano n√£o bissexto
                    AND NOT (
                        mes_nascimento = 2 AND dia_nascimento = 29 AND
                        NOT (
                            (EXTRACT(YEAR FROM CURRENT_DATE)::int % 4 = 0 AND EXTRACT(YEAR FROM CURRENT_DATE)::int % 100 != 0)
                            OR (EXTRACT(YEAR FROM CURRENT_DATE)::int % 400 = 0)
                        )
                    )
                )
                SELECT 
                    enti_empr, codigo,  nome, tipo, aniversario, mes_nascimento, dia_nascimento, contato, email
                FROM aniversarios_validos
                ORDER BY aniversario_deste_ano

            
            Esta consulta:
            - Filtra datas v√°lidas para evitar erros
            - Mostra nome, tipo, data de anivers√°rio e contato
            - Ordena por m√™s e dia do anivers√°rio
            - Trata datas inv√°lidas adequadamente
            - Inclui apenas clientes, vendedores e fornecedores
            - pegue sempre da data atual para calcular o pr√≥ximo anivers√°rio

            """

        # Tratar consultas de t√≠tulos a pagar com empresas
        if 'titulos' in processed and 'pagar' in processed and ('empresa' in processed or 'entidade' in processed):
            processed = """
            Liste os pr√≥ximos t√≠tulos a pagar por empresa com entidades.
            
            IMPORTANTE: Use EXATAMENTE esta consulta para evitar erros de data:
            
            SELECT 
                e.empr_nome as empresa,
                t.titu_desc as descricao_titulo,
                t.titu_valo as valor_titulo,
                CASE 
                    WHEN t.titu_venc IS NOT NULL AND EXTRACT(YEAR FROM t.titu_venc) BETWEEN 1900 AND 2100 
                    THEN t.titu_venc::text 
                    ELSE 'Data inv√°lida' 
                END as vencimento,
                COALESCE(ent.enti_nome, 'Sem entidade') as entidade_nome
            FROM titulospagar t
            JOIN empresas e ON t.titu_empr = e.empr_codi
            LEFT JOIN entidades ent ON t.titu_forn = ent.enti_clie
            WHERE t.titu_valo > 0
            ORDER BY e.empr_nome, t.titu_valo DESC
            LIMIT 10;
            
            Esta consulta:
            - Filtra datas v√°lidas para evitar erros
            - Mostra empresa, valor, descri√ß√£o e entidade
            - Ordena por empresa e valor
            - Trata dados nulos adequadamente
            """
        
        if 'faturamento' in processed:
            processed = """
            
            IMPORTANTE: Use EXATAMENTE esta consulta:
            SELECT 
                EXTRACT(MONTH FROM pedi_data) as mes,
                EXTRACT(YEAR FROM pedi_data) as ano,
                SUM(pedi_tota) as faturamento
            FROM pedidos
            GROUP BY mes, ano
            ORDER BY ano, mes;
            """

        return processed
    
    def _has_critical_error(self, output: str) -> bool:
        """Verifica se a sa√≠da cont√©m erros cr√≠ticos"""
        error_indicators = [
            'column "',
            'does not exist',
            'relation "',
            'year -',
            'is out of range',
            'syntax error',
            'UndefinedColumn',
            'UndefinedTable'
        ]
        
        return any(indicator in output for indicator in error_indicators)
    
    def _classify_error(self, error_msg: str) -> str:
        """Classifica o tipo de erro"""
        for error_type, pattern in self.error_patterns.items():
            if re.search(pattern, error_msg, re.IGNORECASE):
                return error_type.replace('_', ' ').title()
        
        return "Erro Desconhecido"
    
    def _get_error_solutions(self, error_type: str, error_msg: str) -> str:
        """Retorna solu√ß√µes espec√≠ficas para cada tipo de erro"""
        solutions = {
            'Column Not Exist': """
            - Consulte o schema da tabela primeiro: `DESCRIBE nome_da_tabela`
            - Verifique se o nome da coluna est√° correto
            - Use `SELECT * FROM tabela LIMIT 10` para ver as colunas dispon√≠veis
            """,
            'Table Not Exist': """
            - Verifique se o nome da tabela est√° correto
            - Use consulta para listar tabelas dispon√≠veis
            - Confirme se voc√™ tem permiss√£o para acessar a tabela
            """,
            'Date Range Error': """
            - Use formato de data padr√£o: YYYY-MM-DD
            - Verifique se as datas est√£o em um intervalo v√°lido
            - Use fun√ß√µes de convers√£o: TO_DATE() ou CAST()
            """,
            'Syntax Error': """
            - Verifique a sintaxe SQL
            - Confirme se todas as aspas est√£o fechadas
            - Verifique se os nomes das tabelas/colunas est√£o corretos
            """
        }
        
        return solutions.get(error_type, "- Tente uma consulta mais simples\n- Consulte a documenta√ß√£o SQL")
    
    def _attempt_error_recovery(self, original_question: str, error_output: str) -> str:
        """Tenta recuperar automaticamente de erros comuns"""
        try:
            # Se erro de coluna inexistente, tentar sugerir colunas similares
            if 'column "' in error_output and 'does not exist' in error_output:
                return self._suggest_similar_columns(original_question, error_output)
            
            # Se erro de tabela inexistente, listar tabelas dispon√≠veis
            if 'relation "' in error_output and 'does not exist' in error_output:
                return self._list_available_tables()
            
            # Se erro de data, sugerir formato correto e ignorar dados inv√°lidos
            if 'year' in error_output and 'is out of range' in error_output:
                return self._suggest_date_format_with_filter(original_question)
                
        except Exception:
            pass
        
        return None
    
    def _suggest_similar_columns(self, question: str, error_output: str) -> str:
        """Sugere colunas similares quando uma coluna n√£o existe"""
        # Extrair nome da coluna do erro
        match = re.search(r'column "([^"]+)" does not exist', error_output)
        if not match:
            return None
            
        missing_column = match.group(1)
        
        # Mapear colunas comuns com nomes corretos do banco
        column_suggestions = {
            # Entidades
            'id': 'enti_clie',
            'codigo': 'enti_clie',
            'id_cliente': 'enti_clie',
            'codigo_cliente': 'enti_clie',
            'nome': 'enti_nome',
            'nome_cliente': 'enti_nome', 
            'nome_entidade': 'enti_nome',
            'tipo': 'enti_tipo_enti',
            'tipo_entidade': 'enti_tipo_enti',
            'tipo_cliente': 'enti_tipo_enti',
            'endereco': 'enti_ende',
            'estado': 'enti_esta',
            'telefone': 'enti_tele',
            'celular': 'enti_celu',
            
            # Produtos
            'codigo_produto': 'prod_codi',
            'nome_produto': 'prod_nome',
            
            # Pedidos
            'numero_pedido': 'pedi_nume',
            'data_pedido': 'pedi_data',
            'data': 'pedi_data',
            'fornecedor_pedido': 'pedi_forn',
            'total_pedido': 'pedi_tota',
            'valor_total': 'pedi_tota',
            'valor': 'pedi_tota',
            'faturamento': 'pedi_tota',

            
            # Itens pedido
            'quantidade': 'iped_quan',
            'preco_unitario': 'iped_unit',
            'preco': 'iped_unit',
            'valor_item': 'iped_tota',
            
            # T√≠tulos
            'valor_titulo': 'titu_valo',
            'vencimento': 'titu_venc'
        }
        
        suggestion = column_suggestions.get(missing_column.lower())
        if suggestion:
            # Determinar a tabela baseada no contexto
            table_context = ""
            if suggestion.startswith('enti_'):
                table_context = " (tabela: entidades)"
            elif suggestion.startswith('prod_'):
                table_context = " (tabela: produtos)"
            elif suggestion.startswith('pedi_'):
                table_context = " (tabela: pedidosvenda)"
            elif suggestion.startswith('iped_'):
                table_context = " (tabela: itenspedidovenda)"
            elif suggestion.startswith('titu_'):
                table_context = " (tabela: titulospagar/titulosreceber)"
                
            return f"""**üîß Corre√ß√£o autom√°tica detectada:**

A coluna `{missing_column}` n√£o existe, mas encontrei a coluna correta: `{suggestion}`{table_context}

**üí° Sugest√£o:** Use `{suggestion}` ao inv√©s de `{missing_column}`.

**Exemplo de consulta correta:**
```sql
SELECT {suggestion}, COUNT(*) 
FROM entidades 
GROUP BY {suggestion} 
LIMIT 10;
```

**üìã Campos dispon√≠veis na tabela entidades:**
- enti_clie (ID da entidade)
- enti_nome (Nome)
- enti_tipo_enti (Tipo: CL, FO, VE, TR, OU, AM)
- enti_ende (Endere√ßo)
- enti_esta (Estado)
- enti_tele (Telefone)
- enti_celu (Celular)
"""
        
        # Se n√£o encontrou sugest√£o espec√≠fica, mostrar campos dispon√≠veis
        return f"""**‚ùå Coluna `{missing_column}` n√£o encontrada**

**üìã Campos dispon√≠veis por tabela:**

**entidades:**
- enti_clie, enti_nome, enti_tipo_enti, enti_ende, enti_esta, enti_tele, enti_celu

**produtos:**
- prod_codi, prod_nome

**pedidosvenda:**
- pedi_nume, pedi_data, pedi_forn, pedi_tota

**itenspedidovenda:**
- iped_pedi, iped_prod, iped_quan, iped_unit, iped_tota

**üí° Use EXATAMENTE estes nomes de campos em suas consultas.**
"""
    
    def _list_available_tables(self) -> str:
        """Lista tabelas dispon√≠veis quando uma tabela n√£o √© encontrada"""
        return """**üìã Tabelas dispon√≠veis no sistema:**

üîπ **entidades** - Clientes, fornecedores, vendedores, transportadoras
   Campos: enti_clie, enti_nome, enti_tipo_enti, enti_ende, enti_esta, enti_tele, enti_celu

üîπ **produtos** - Cadastro de produtos
   Campos: prod_codi, prod_nome

üîπ **saldosprodutos** - Saldos e movimenta√ß√µes de produtos
   Campos: sapr_prod, sapr_sald

üîπ **pedidosvenda** - Pedidos de venda
   Campos: pedi_nume, pedi_data, pedi_forn, pedi_tota

üîπ **itenspedidovenda** - Itens dos pedidos de venda
   Campos: iped_pedi, iped_prod, iped_quan, iped_unit, iped_tota

üîπ **titulospagar** - Contas a pagar
   Campos: titu_id, titu_forn, titu_valo, titu_venc

üîπ **titulosreceber** - Contas a receber
   Campos: titu_id, titu_clie, titu_valo, titu_venc

**üí° Exemplo de consulta correta:**
```sql
SELECT enti_tipo_enti, COUNT(*) as quantidade 
FROM entidades 
GROUP BY enti_tipo_enti 
ORDER BY quantidade DESC;
```
"""
    
    def _suggest_date_format(self, question: str) -> str:
        """Sugere formato correto de data"""
        return """**üìÖ Erro de formato de data detectado:**

**Formatos corretos:**
- `'2024-01-15'` (YYYY-MM-DD)
- `TO_DATE('15/01/2024', 'DD/MM/YYYY')`
- `CAST('2024-01-15' AS DATE)`

**üí° Dica:** Use sempre anos entre 1900 e 2100 e formatos padr√£o ISO.

**Exemplo de consulta correta:**
```sql
SELECT * FROM pedidosvenda WHERE pedi_data >= '2024-01-01' LIMIT 10
```
"""

    def _suggest_date_format_with_filter(self, question: str) -> str:
        """Sugere formato correto de data e como filtrar dados inv√°lidos"""
        
        # Se a pergunta √© sobre aniversariantes
        if 'aniversar' in question.lower() or 'nascimento' in question.lower():
            return """**üìÖ Erro de data detectado - Consulta de Aniversariantes:**

**üîß Solu√ß√£o espec√≠fica para listar aniversariantes:**

```sql
SELECT 
    enti_nome as nome,
    enti_tipo_enti as tipo,
    CASE 
        WHEN enti_nasc IS NOT NULL AND EXTRACT(YEAR FROM enti_nasc) BETWEEN 1900 AND 2100 
        THEN TO_CHAR(enti_nasc, 'DD/MM') 
        ELSE 'Data inv√°lida' 
    END as aniversario,
    CASE 
        WHEN enti_nasc IS NOT NULL AND EXTRACT(YEAR FROM enti_nasc) BETWEEN 1900 AND 2100 
        THEN EXTRACT(MONTH FROM enti_nasc)
        ELSE 99 
    END as mes_nascimento,
    COALESCE(enti_tele, enti_celu, 'Sem telefone') as contato
FROM entidades 
WHERE enti_tipo_enti IN ('CL', 'VE', 'FO')
ORDER BY mes_nascimento, EXTRACT(DAY FROM enti_nasc)
LIMIT 20;
```

**‚úÖ Esta consulta:**
- Evita erros de data usando CASE WHEN e EXTRACT
- Mostra nome, tipo, data de anivers√°rio e contato
- Filtra apenas clientes, vendedores e fornecedores
- Trata datas inv√°lidas adequadamente
- Ordena por m√™s e dia do anivers√°rio

**üí° Use sempre esta estrutura para consultas de aniversariantes!**
"""
        
        # Se a pergunta √© sobre t√≠tulos a pagar
        if 'titulo' in question.lower() and 'pagar' in question.lower():
            return """**üìÖ Erro de data detectado - Consulta de T√≠tulos a Pagar:**

**üîß Solu√ß√£o espec√≠fica para t√≠tulos a pagar por empresa:**

```sql
SELECT 
    e.empr_nome as empresa,
    t.titu_desc as descricao,
    t.titu_valo as valor,
    CASE 
        WHEN t.titu_venc IS NOT NULL AND EXTRACT(YEAR FROM t.titu_venc) BETWEEN 1900 AND 2100 
        THEN t.titu_venc::text 
        ELSE 'Data inv√°lida' 
    END as vencimento,
    COALESCE(ent.enti_nome, 'Sem entidade') as entidade
FROM titulospagar t
JOIN empresas e ON t.titu_empr = e.empr_codi
LEFT JOIN entidades ent ON t.titu_forn = ent.enti_clie
WHERE t.titu_valo > 0
ORDER BY e.empr_nome, t.titu_valo DESC
LIMIT 10;
```

**‚úÖ Esta consulta:**
- Evita erros de data usando CASE WHEN
- Mostra empresa, valor, descri√ß√£o e entidade
- Filtra apenas t√≠tulos com valor > 0
- Trata datas inv√°lidas como texto
- Ordena por empresa e valor

**üí° Use sempre esta estrutura para consultas com datas problem√°ticas!**
"""
        
        # Solu√ß√£o geral para outros casos
        return """**üìÖ Erro de data detectado - dados inv√°lidos no banco:**

**üö® Problema:** O banco cont√©m registros com datas inv√°lidas (anos negativos ou fora do range).

**üîß Solu√ß√µes:**

**1. Filtrar datas v√°lidas:**
```sql
SELECT * FROM tabela 
WHERE data_campo >= '1900-01-01' 
AND data_campo <= '2100-12-31' 
LIMIT 10
```

**2. Usar CASE WHEN para tratar datas inv√°lidas:**
```sql
SELECT *,
    CASE 
        WHEN EXTRACT(YEAR FROM data_campo) BETWEEN 1900 AND 2100 
        THEN data_campo::text 
        ELSE 'Data inv√°lida' 
    END as data_tratada
FROM tabela 
LIMIT 10
```

**3. Usar COALESCE para tratar nulos:**
```sql
SELECT *, COALESCE(data_campo, '2000-01-01') as data_valida 
FROM tabela 
WHERE EXTRACT(YEAR FROM data_campo) BETWEEN 1900 AND 2100
LIMIT 10
```

**üí° Dica:** Sempre use filtros de data para evitar registros com dados corrompidos.
"""
    